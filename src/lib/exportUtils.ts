import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';

// Types for export data
export interface ExportData {
  title: string;
  subtitle?: string;
  dateRange: string;
  data: Record<string, unknown>[];
  summary?: Record<string, unknown>;
  metadata?: Record<string, unknown>;
}

export interface ExportOptions {
  filename?: string;
  orientation?: 'portrait' | 'landscape';
  format?: 'a4' | 'letter';
  includeCharts?: boolean;
  includeHeader?: boolean;
  includeFooter?: boolean;
}

// PDF Export Functions
export const exportToPDF = async (
  elementId: string,
  data: ExportData,
  options: ExportOptions = {}
): Promise<void> => {
  try {
    const {
      filename = `${data.title.toLowerCase().replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}`,
      orientation = 'portrait',
      format = 'a4',
      includeHeader = true,
      includeFooter = true
    } = options;

    // Create PDF instance
    const pdf = new jsPDF({
      orientation,
      unit: 'mm',
      format
    });

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;

    // Add header
    if (includeHeader) {
      pdf.setFontSize(20);
      pdf.setFont('helvetica', 'bold');
      pdf.text(data.title, margin, margin + 10);

      if (data.subtitle) {
        pdf.setFontSize(12);
        pdf.setFont('helvetica', 'normal');
        pdf.text(data.subtitle, margin, margin + 20);
      }

      pdf.setFontSize(10);
      pdf.text(`Date Range: ${data.dateRange}`, margin, margin + 30);
      pdf.text(`Generated: ${new Date().toLocaleString()}`, margin, margin + 35);

      // Add separator line
      pdf.setLineWidth(0.5);
      pdf.line(margin, margin + 40, pageWidth - margin, margin + 40);
    }

    // Capture the element as canvas
    const element = document.getElementById(elementId);
    if (element) {
      const canvas = await html2canvas(element, {
        scale: 2,
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff'
      });

      const imgData = canvas.toDataURL('image/png');
      const imgWidth = pageWidth - (margin * 2);
      const imgHeight = (canvas.height * imgWidth) / canvas.width;

      let yPosition = includeHeader ? margin + 50 : margin;

      // Check if image fits on one page
      if (imgHeight <= pageHeight - yPosition - (includeFooter ? 20 : 0)) {
        pdf.addImage(imgData, 'PNG', margin, yPosition, imgWidth, imgHeight);
      } else {
        // Split image across multiple pages
        const pageContentHeight = pageHeight - yPosition - (includeFooter ? 20 : 0);
        const totalPages = Math.ceil(imgHeight / pageContentHeight);

        for (let i = 0; i < totalPages; i++) {
          if (i > 0) {
            pdf.addPage();
            yPosition = margin;
          }

          const sourceY = i * pageContentHeight * (canvas.height / imgHeight);
          const sourceHeight = Math.min(pageContentHeight * (canvas.height / imgHeight), canvas.height - sourceY);

          // Create a temporary canvas for this page section
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = canvas.width;
          tempCanvas.height = sourceHeight;
          const tempCtx = tempCanvas.getContext('2d');
          
          if (tempCtx) {
            tempCtx.drawImage(canvas, 0, sourceY, canvas.width, sourceHeight, 0, 0, canvas.width, sourceHeight);
            const tempImgData = tempCanvas.toDataURL('image/png');
            const tempImgHeight = (sourceHeight * imgWidth) / canvas.width;
            pdf.addImage(tempImgData, 'PNG', margin, yPosition, imgWidth, tempImgHeight);
          }
        }
      }
    }

    // Add footer
    if (includeFooter) {
      const totalPages = (pdf as jsPDF).internal.pages.length;
      for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        pdf.setFontSize(8);
        pdf.setFont('helvetica', 'normal');
        pdf.text(
          `Page ${i} of ${totalPages}`,
          pageWidth - margin - 20,
          pageHeight - 10
        );
        pdf.text(
          'Generated by Quantumnexa Finance App',
          margin,
          pageHeight - 10
        );
      }
    }

    // Save the PDF
    pdf.save(`${filename}.pdf`);
  } catch (error) {
    console.error('Error exporting to PDF:', error);
    throw new Error('Failed to export PDF');
  }
};

// Excel Export Functions
export const exportToExcel = (data: ExportData, options: ExportOptions = {}): void => {
  try {
    const {
      filename = `${data.title.toLowerCase().replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}`
    } = options;

    // Create CSV content
    let csvContent = '';

    // Add header information
    csvContent += `${data.title}\n`;
    if (data.subtitle) {
      csvContent += `${data.subtitle}\n`;
    }
    csvContent += `Date Range: ${data.dateRange}\n`;
    csvContent += `Generated: ${new Date().toLocaleString()}\n\n`;

    // Add summary if available
    if (data.summary) {
      csvContent += 'SUMMARY\n';
      Object.entries(data.summary).forEach(([key, value]) => {
        csvContent += `${key},${value}\n`;
      });
      csvContent += '\n';
    }

    // Add main data
    if (data.data && data.data.length > 0) {
      csvContent += 'DETAILED DATA\n';
      
      // Get headers from first data item
      const headers = Object.keys(data.data[0]);
      csvContent += headers.join(',') + '\n';

      // Add data rows
      data.data.forEach(row => {
        const values = headers.map(header => {
          const value = row[header];
          // Handle values that might contain commas
          if (typeof value === 'string' && value.includes(',')) {
            return `"${value}"`;
          }
          return value || '';
        });
        csvContent += values.join(',') + '\n';
      });
    }

    // Create and download file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    
    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `${filename}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  } catch (error) {
    console.error('Error exporting to Excel:', error);
    throw new Error('Failed to export to Excel');
  }
};

// Advanced Excel export with better formatting (requires additional library)
export const exportToAdvancedExcel = async (data: ExportData, options: ExportOptions = {}): Promise<void> => {
  // This would require xlsx library for better Excel formatting
  // For now, fallback to CSV export
  exportToExcel(data, options);
};

// Utility function to format currency for exports
export const formatCurrencyForExport = (amount: number): string => {
  return new Intl.NumberFormat('en-PK', {
    style: 'currency',
    currency: 'PKR',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount);
};

// Utility function to format percentage for exports
export const formatPercentageForExport = (percentage: number): string => {
  return `${percentage.toFixed(2)}%`;
};

// Utility function to format date for exports
export const formatDateForExport = (date: string | Date): string => {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  return dateObj.toLocaleDateString('en-PK');
};

// Utility function to prepare data for export
export const prepareDataForExport = (
  rawData: Record<string, unknown>[],
  formatters: Record<string, (value: unknown) => string> = {}
): Record<string, unknown>[] => {
  return rawData.map(item => {
    const formattedItem: Record<string, unknown> = {};
    Object.entries(item).forEach(([key, value]) => {
      if (formatters[key]) {
        formattedItem[key] = formatters[key](value);
      } else {
        formattedItem[key] = value;
      }
    });
    return formattedItem;
  });
};

// Export report with both PDF and Excel options
export const exportReport = async (
  elementId: string,
  data: ExportData,
  format: 'pdf' | 'excel' | 'both',
  options: ExportOptions = {}
): Promise<void> => {
  try {
    if (format === 'pdf' || format === 'both') {
      await exportToPDF(elementId, data, options);
    }
    
    if (format === 'excel' || format === 'both') {
      exportToExcel(data, options);
    }
  } catch (error) {
    console.error('Error exporting report:', error);
    throw error;
  }
};